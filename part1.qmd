---
pagetitle: "`r paste('Transactions exercise part 1', Sys.Date())`"
format: 
  html:
    page-layout: full
    embed-resources: true
toc: true
toc-expand: true
execute:
  echo: true
  warning: false
html-table-processing: none
engine: knitr
---

{{< include header.qmd >}}

# Part 1

## Setup

### Libraries

```{r}
#| label: libraries
library(DBI)
library(dplyr)
library(duckdb)
```

### Globals

```{r}
#| label: globals
source(file.path("R", "functions.R"))

TRANSACTIONS_PATH_RAW <- "data/raw/current-acc-trans.csv"
TRANSACTIONS_PATH_CLEAN <- "data/clean/current-acc-trans.csv"
ACCOUNTS_PATH_RAW <- "data/raw/accounts.csv"
ACCOUNTS_PATH_CLEAN <- "data/clean/accounts.csv"
TRANSACTIONS_PER_CUSTOMER_PATH <- "data/results/transactions-per-customer.csv"
RESULTS_PATH <- "data/results/merged.csv"
```

## Clean

Cleaning up the accounts dataset.
 
The cleaning is minimal - I have only done what is required for the tasks.

During initial EDA of the `account_type` col I saw there were both
`current` and `current+` account types. I wondered if the plus symbol was a
typo, but there are 6,688 and 1,366 of each, respectively. This seems like
too many `current+` to be an accident, so I didn't clean and combine the two
groups.

The regex below removes all whitespace `\s` and non-word `\W` chars from
`title`, so that e.g. `Mr.` becomes `Mr` - Otherwise they appear as two
separate categories.

There's also a rogue single space in a row in the `account_type` column.
I decided to clean that at read-time by setting `nullstr`.

```{r}
#| label: clean-accounts-csv
#| output: false

ddbExecute(
  "
  COPY (
    SELECT *
      REPLACE (
        title.regexp_replace('\\s|\\W', '', 'g').lower() AS title,
        account_type.trim().lower() AS account_type
      )
      FROM read_csv(?, nullstr = [' ', ''])
  ) TO ?;
  ",
  from_path = ACCOUNTS_PATH_RAW,
  to_path = ACCOUNTS_PATH_CLEAN
)
```

## 1. Titles

::: {.callout-note}
Count the number of account holders with each title
:::

I'm not sure about the group `m` in the results. In real life I'd want to be more familiar with this - is it real? Or just a common typo for `Mr` and `Ms`? Left it in for now.

```{r}
#| label: titles

n_titles <- ddbGetQuery(
  "
  SELECT title as Title, COUNT(*) as Count
  FROM ?
  GROUP BY title
  ORDER By Count DESC;
  ",
  from = ACCOUNTS_PATH_CLEAN
)

n_titles
```

## 2. Account holders by title and account type

::: {.callout-note}
Produce a cross-table showing the number of account holders broken down by title and account_type (i.e. a count of the number of people with each combination of possible account types and titles)
:::

```{r}
#| label: title-vs-account-type

title_vs_account_type <- ddbGetQuery(
  "
  SELECT title as Title,
         account_type as 'Account Type',
         count(*) as Count
  FROM ?
  WHERE account_type IS NOT NULL
  GROUP BY ALL
  ORDER BY ALL;
  ",
  from = ACCOUNTS_PATH_CLEAN
)

title_vs_account_type
```

## 3. Average overdraft limit by title and account type

::: {.callout-note}
Produce a cross-table showing the average overdraft_limit by title and account_type
:::

Assuming that "average" is the mean

```{r}
#| label: avg-overdraft-limit-by-title-and-account-type

avg_overdraft_limits <- ddbGetQuery(
  "
  SELECT title as Title,
         account_type as 'Account Type',
         avg(overdraft_limit) as 'Average Overdraft Limit'
  FROM ?
  WHERE account_type IS NOT NULL
  GROUP BY ALL
  ORDER BY ALL;
  ",
  from = ACCOUNTS_PATH_CLEAN
)

avg_overdraft_limits
```

## 4. Overdraft limit summed by title and account type

::: {.callout-note}
Produce a cross-table showing the aggregate `overdraft_limit` (sum of) by `title` and `account_type`
:::

```{r}
#| label: overdraft-sum-by-title-and-account-type

overdrafts_summed <- ddbGetQuery(
  "
  SELECT title as Title,
         account_type as 'Account Type',
         sum(overdraft_limit) as 'Overdraft Limit Sum'
  FROM ?
  WHERE account_type IS NOT NULL
  GROUP BY ALL
  ORDER BY ALL;
  ",
  from = ACCOUNTS_PATH_CLEAN
)

overdrafts_summed
```

## 5. Transactions per customer

::: {.callout-note}
For each customer count the number of transactions in the transaction data and compute the total value of those transactions for each customer
:::

There are 10,000 account numbers in accounts.csv
And 64,498 unique account numbers in the transaction data

I'm guessing that the people in accounts.csv are our customers. So I filter down the transaction data to only include them.

To get the unique counts of accounts
```{r}
list(
  ddbGetQuery("select count(distinct account_number) from 'data/clean/accounts.csv';"),
  ddbGetQuery("select count(distinct acc_number) from 'data/clean/current-acc-trans.csv';")
)
```

Due diligence: confirmed that the number of unique `transaction_ids` is equal to the transaction dataset's nrow
```{r}
list(
  ddbGetQuery("select count(distinct trans_id) from 'data/clean/current-acc-trans.csv';"),
  ddbGetQuery("select count(*) from 'data/clean/current-acc-trans.csv';")
)
```

Using a semi join here. It's a kind of filtering join. The left table gets
filtered down to only include matches from the right table.

```{r}
#| label: transactions-per-customer

transactions_per_customer <- ddbGetQuery(
  "
  SELECT acc_number as account_number,
         count(*) as transactions_count,
         sum(amount) as total_transaction_value
  FROM ? t
  SEMI JOIN ? a
         ON t.acc_number = a.account_number
  GROUP BY t.acc_number
  ORDER BY transactions_count;
  ",
  t = TRANSACTIONS_PATH_CLEAN,
  a = ACCOUNTS_PATH_CLEAN
) |>
  dplyr::arrange(dplyr::desc(transactions_count))

# A few accounts have huge number of transactions, e.g. 11336875 has 693
# Took a look at the individual records - seems fine... Though they seem to be
# awake at all hours of the day!
# dplyr::arrange(
#   ddbGetQuery(
#     "select *
#         from 'data/clean//current-acc-trans.csv'
#         where acc_number = '11336875';"
#   ),
#   trans_date
# )

summary(transactions_per_customer)
```

## 6. Join transaction summary to accounts

::: {.callout-note}
Now add the results from the previous step to the accounts dataset, in an appropriate data architecture to answer part 2.
:::

```{r}
#| label: join-transaction-summary-to-accounts
#| output: false

con <- DBI::dbConnect(duckdb::duckdb())
duckdb::duckdb_register(con, "transactions_per_customer", transactions_per_customer)
DBI::dbExecute(con, "COPY transactions_per_customer TO 'data/results/transactions-per-customer.csv';")
DBI::dbDisconnect(con)

ddbExecute(
  "
  COPY (
    SELECT *
    FROM ? a
    LEFT JOIN ? t_agg
           ON a.account_number = t_agg.account_number
    ) TO ?;
  ",
  a = ACCOUNTS_PATH_CLEAN,
  t_agg = TRANSACTIONS_PER_CUSTOMER_PATH,
  out = RESULTS_PATH
)
```